



Information-Centric Networking Research Group (ICNRG)        F. Lastname
Internet-Draft                                               Affiliation
Intended status: Informational                         November 12, 2016
Expires: May 16, 2017


 Design Choices and Differences for NDN and CCNx 1.0 Implementations of
                     Information-Centric Networking
                      draft-icnrg-harmonization-00

Abstract

   The purpose of this draft is to document the discussions of the ICN
   Harmonization Study Group regarding the architectural or design
   choices made in the NDN and CCNx 1.0 implementations and to describe
   the rationale (if any) underlying the choices.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on May 16, 2017.

Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.



Lastname                  Expires May 16, 2017                  [Page 1]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  Background  . . . . . . . . . . . . . . . . . . . . . . . . .   3
     3.1.  CCNx 0.8: Origin and Point of Commonality . . . . . . . .   3
       3.1.1.  Interest name matching  . . . . . . . . . . . . . . .   6
       3.1.2.  Other Interest fields . . . . . . . . . . . . . . . .   8
       3.1.3.  Forwarder Behavior  . . . . . . . . . . . . . . . . .   9
       3.1.4.  Content Store . . . . . . . . . . . . . . . . . . . .  10
       3.1.5.  Wireformat  . . . . . . . . . . . . . . . . . . . . .  11
     3.2.  Recognized Issues with CCNx 0.8 . . . . . . . . . . . . .  11
     3.3.  Summary of NDN and CCNx 1.0 Evolution . . . . . . . . . .  12
       3.3.1.  NDN Evolution . . . . . . . . . . . . . . . . . . . .  12
       3.3.2.  CCNx 1.0 Evolution  . . . . . . . . . . . . . . . . .  13
   4.  Discussion of Individual Architecture & Design Commonalities
       and Differences per NDN and CCNx 1.0 Development paths  . . .  15
     4.1.  Packet encoding . . . . . . . . . . . . . . . . . . . . .  15
       4.1.1.  NDN . . . . . . . . . . . . . . . . . . . . . . . . .  15
       4.1.2.  CCNx 1.0  . . . . . . . . . . . . . . . . . . . . . .  15
     4.2.  Packet structure (network adaptation, link adaptation,
           information layers) . . . . . . . . . . . . . . . . . . .  16
       4.2.1.  NDN . . . . . . . . . . . . . . . . . . . . . . . . .  16
       4.2.2.  CCNx 1.0  . . . . . . . . . . . . . . . . . . . . . .  16
     4.3.  Naming  . . . . . . . . . . . . . . . . . . . . . . . . .  17
     4.4.  Data retrieval  . . . . . . . . . . . . . . . . . . . . .  17
       4.4.1.  NDN . . . . . . . . . . . . . . . . . . . . . . . . .  17
       4.4.2.  CCNx 1.0  . . . . . . . . . . . . . . . . . . . . . .  17
     4.5.  Data retrieval scoping  . . . . . . . . . . . . . . . . .  17
       4.5.1.  NDN . . . . . . . . . . . . . . . . . . . . . . . . .  17
       4.5.2.  CCNx 1.0  . . . . . . . . . . . . . . . . . . . . . .  17
     4.6.  Opportunistic in-network caching  . . . . . . . . . . . .  17
       4.6.1.  NDN . . . . . . . . . . . . . . . . . . . . . . . . .  18
       4.6.2.  CCNx 1.0  . . . . . . . . . . . . . . . . . . . . . .  18
     4.7.  In-network name discovery . . . . . . . . . . . . . . . .  18
       4.7.1.  NDN . . . . . . . . . . . . . . . . . . . . . . . . .  18
       4.7.2.  CCNx 1.0  . . . . . . . . . . . . . . . . . . . . . .  18
     4.8.  Forwarding Loop Management  . . . . . . . . . . . . . . .  18
       4.8.1.  NDN . . . . . . . . . . . . . . . . . . . . . . . . .  18
       4.8.2.  CCNX 1.0  . . . . . . . . . . . . . . . . . . . . . .  19
     4.9.  Similar Interest Aggregation  . . . . . . . . . . . . . .  19
       4.9.1.  NDN . . . . . . . . . . . . . . . . . . . . . . . . .  19
       4.9.2.  CCNx 1.0  . . . . . . . . . . . . . . . . . . . . . .  19
     4.10. Interest Payloads . . . . . . . . . . . . . . . . . . . .  20
     4.11. Data Security . . . . . . . . . . . . . . . . . . . . . .  20
       4.11.1.  NDN  . . . . . . . . . . . . . . . . . . . . . . . .  20
       4.11.2.  CCNx 1.0 . . . . . . . . . . . . . . . . . . . . . .  20
     4.12. Fragmentation . . . . . . . . . . . . . . . . . . . . . .  21



Lastname                  Expires May 16, 2017                  [Page 2]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


     4.13. Indirect data retrieval . . . . . . . . . . . . . . . . .  21
       4.13.1.  NDN  . . . . . . . . . . . . . . . . . . . . . . . .  21
       4.13.2.  CCNx 1.0 . . . . . . . . . . . . . . . . . . . . . .  21
     4.14. Sync  . . . . . . . . . . . . . . . . . . . . . . . . . .  21
       4.14.1.  NDN  . . . . . . . . . . . . . . . . . . . . . . . .  21
       4.14.2.  CCNx 1.0 . . . . . . . . . . . . . . . . . . . . . .  21
   5.  Security Considerations . . . . . . . . . . . . . . . . . . .  21
   6.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  21
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  21
   8.  Normative References  . . . . . . . . . . . . . . . . . . . .  22
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  22

1.  Introduction

   ...

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119.

   (TBD) Reference to terminology draft

3.  Background

3.1.  CCNx 0.8: Origin and Point of Commonality

   The CCNx 0.8 research prototype produced by PARC embodied a set of
   network functionality and application functionality that reflects a
   strong application layer framing approach.  At the network level, a
   forwarder provides several services: (a) Interest aggregation, (b)
   Interest forwarding, (c) Content Object forwarding along the Interest
   reverse path, (d) Content Object caching, (e) routing strategies, and
   (f) in-network discovery of content via partial Interest name
   matching.  The application domain has all other functionality, such
   as reliable delivery, Interest retransmissions, signature
   verification, encryption, and name discovery techniques.

   The CCNx 0.8 network protocol is built around an Interest (requst)
   message and a Content Object (response) message.  Each Interest will
   bring back at most one Content Object.  This is true for Interests
   doing in-network discovery and for Interests doing data fetches.  An
   in-network discovery Interest expresses a name prefix and some
   parameters (discussed below) to limit the scope of acceptable
   response names.  In turn, the first cache (Content Store) or producer
   along the Interest path that has or can generate a Content Object
   with satisfactory name responds with that Content Object.  Thus,



Lastname                  Expires May 16, 2017                  [Page 3]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   discovery works one request and response at a time.  In part this is
   because a requester needs to look at the entire Content Object to
   determine if it truly satisfies the request based on its attributes
   and its provenance.

   CCNx 0.8 matches a Content Object to an Interest (the Content Objec
   satisfies the Interest) based on several attributes of the Content
   Object and parameters in the Interest.  There is not a one-to-one
   correspondence, so several different Content Objects could match the
   same Interest or the same Content Object could match several
   Interests; in the latter case, we call the Interests similar.
   Because there is not a simple rule to determine if two interests are
   similar, the CCNx forwarder uses a simplification: two Interests are
   called similar if all Content Object matching terms are equal.  This
   was accomplished by using a hash over the wireformat of those
   matching terms in the Interest.

   In CCNx 0.8, a Content Object name is a totally ordered hierarchical
   namespace.  At the network layer, each name component is a variable
   length opaque byte string of 0 or more bytes.  Name components use a
   shortlex comparison: if component A is shorter than component B, then
   A comes before B, otherwise if they are the same length use a byte-
   wise lexicographic order.  Two names are sorted based on where the
   first difference occurs in their name components.  For Names, the
   ordering is just based on the ordering of the first component where
   they differ.  If one name is a proper prefix of the other, then it
   comes first.  This ordering is called the canonical name order.

   An Interest name comes in three types, differentiated by their
   intended purpose.  A 'prefix' name is used in name discovery.  It is
   not intended to match any specific Content Object, but rather to
   elicit a response of likely Content Objects.  An 'exact' name in an
   Interest exactly matches a name in a Content Object.  A 'full' name
   is not used in discovery: it should specifically identify a single
   Content Object because it includes the cryptographic hash of the
   Content Object.

   The explicit name in a Content Object has 0 or more name components
   assigned by the application.  Some of these may be used by routing
   and some may be used by application-defined protocols, such as
   versioning or segmentation.  A Content Object name has one terminal
   implicit name component: the so-called implicit hash.  This is the
   SHA-256 hash of the Content Object itself (and thus cannot be
   explicit).  A forwarder, when handling a Content Object, always
   considers the Content Object to have the implicit name component.
   This means that both 'prefix' and 'exact' names do in-network
   discovery because they are always including at least one extra name
   component.  For example, if a Content Object has a name /foo/bar,



Lastname                  Expires May 16, 2017                  [Page 4]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   then it's full name is /foo/bar/(hash_value).  A prefix name could be
   /foo (matching 0 or more suffix components), the exact name is /foo/
   bar (matching exactly 1 suffix component) and the full name is /foo/
   bar/(hash_value) (matching 0 additional suffix components).  The
   restrictions on the number of additional suffix components is
   critical in the type of name and the expected matching (the details
   in an Interest are below).

   CCNx 0.8 used some naming conventions that extended the prior
   description.  For example, a metadata Content Object described
   another Content Object.  It's naming convention is /foo/
   bar/(version)/META/(version)/(segment)/(hash_value).  The name
   /foo/bar/5/META/3/0/(hash_value), for example, identifies a metadata
   Content Object of version 3 and segment 0 that describes another
   Content Object names /foo/bar with version 5.

   Because names are totally ordered, one can exploit this in a name
   discovery protocol.  A consumer application may emit an Interest
   whose name is a prefix of one or more Content Objects stored at a
   forwarded (or peer application).  The discovery protocol allows the
   consumer to walk the name tree rooted at the Interest prefix.  The
   consumer can ask for left-most-child or right-most-child and it can
   also specify Exclusions that move a notional cursor through the sub-
   namespace.  In addition to range exclusion, an Interest may exclude
   individual Content Objects.  Based on the name prefix, the child
   direction preference, and the exclusions, a forwarder (or peer
   application) responds with the first Content Object in the canonical
   name order.  One issue that was never handled well in the
   implementation is when there are two Content Objects that differ only
   in hash, but not in name.  While it is possible to navigate this
   situation (see example below), it requires multiple Interest packets
   and some of the protocol libraries never satisfactorily addressed the
   possibility.

   The common naming convention in CCNx 0.8 is a prefix, such as /a/b/c,
   followed by a version, followed by a segment number, followed by the
   implicit hash value: /a/b/c/version/segment/(hash_value).  The
   version is usually a timestamp in network byte order using the
   minimum number of bytes for the number, but it may be any field that
   sorts as per canonical order.  The segment is used to fragment a
   large piece of application data into several Content Objects.  It is
   usually a sequential number beginning at 0.  The version and segment
   number are indicated in the name by assuming other name components
   conform to UTF-8, so the version and segment number use a 'name
   marker' whose first byte is an invalid UTF-8 code.  In CCNx 0.8,
   there is an ambiguity between these name markers and binary name
   components that are not UTF-8 and happen to begin with the same byte
   sequence.



Lastname                  Expires May 16, 2017                  [Page 5]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   Up to this point, we have not been including the command marker
   identifiers in our example names.  Versions, for example, use "%FD",
   segments use "%00."  Another special class of markers are the
   namespace markers.  These indicate that the remaining bytes in the
   name component introduce a new namespace, such as for metadata
   (%C1.META) or repository commands (%C1.R).  There is also a namespace
   for machine-readable name components, such as keyids (%C1.M.K%00(key
   id value)).  In the remainder of this section, we will continue to
   abbreviate names and not include the command markers.  A complete
   reference on command markers is available at
   https://github.com/ProjectCCNx/ccnx/blob/master/doc/technical/
   NameConventions.txt.

   A CCNx 0.8 Interest is defined as Interest ::= Name,
   MinSuffixComponents?, MaxSuffixComponents?,
   PublisherPublicKeyDigest?, Exclude?, ChildSelector?,
   AnswerOriginKind?, Scope?, InterestLifetime?, Nonce?, FaceID?. We
   discuss these parameters in the following.  The set of fields that
   determine if two interests are similar are (_Name_,
   _MinSuffixComponents_, _MaxSuffixComponents_,
   _PublisherPublicKeyDigest_, _Exclude_).

3.1.1.  Interest name matching

   An Interest has 'selectors' that determine how a Content Object name
   matches the Interest name prefix.  The selectors are:
   (_MinSuffixComponents_, _MaxSuffixComponents_, _Exclude_,
   _ChildSelector_).  These are all optional.  If none are given in an
   Interest, the Interest will match any suffix of the Interest's name
   prefix (including 0 suffix components).

   MinSuffixComponents specifies the minimum additional suffix
   components necessary to match and MaxSuffixComponents is similarly
   the maximum allowed.  An exact name would specify (1,1), that is it
   need the implicit hash and only the implicit hash.  A full name,
   which already has the implicit hash, would specify (0,0).  A typical
   type of discovery is Get Latest Version, where a name is understood
   to be of the form /a/b/c/version/segment/(hash_value).  An
   application emits an Interest with prefix /a/b/c with (3, 3) for the
   suffix components and asks for the right-most-child.  This says that
   the application knows that /a/b/c is the specific prefix it wants,
   and it only needs to discover the latest (right-most) version name
   component.

   The ChildSelector works as we have illustrated it above.  An Interest
   name, as limited by MinSuffixComponents and MaxSuffixComponents, will
   induce a totally ordered subset of names rooted at the Interest name.
   They are totally ordered because they include the implicit hash



Lastname                  Expires May 16, 2017                  [Page 6]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   terminal component and we will assume there are no collisions.  The
   ChildSelector defaults to left-most-child (the first of the set).  If
   one is only interested in the largest name, one can specify the
   right-most-child.

   The Exclude term filters out results from the totally ordered subset
   of names rooted at the Interest name.  It can include 0 or more range
   restrictions and 0 or more singleton restrictions.  In typical use in
   discovery it is a single range restrictions to keep walking through
   the subset.  Another common usage is to exclude specific implicit
   hash name components because they are not the desired result (e.g.
   the signature is invalid).  The exclude filter only applies to the
   next name component after the Interest prefix.  For example, if the
   Interest name is /a/b/c, then the Exclude will only apply to the name
   component after /c.  Thus, if one wants to Get Latest Version, the
   Interest name is /a/b/c and the Exclude range would apply to the
   version component of a name like /a/b/c/version/segment/(hash_value).

   There are several subtleties to walking the name space via
   exclusions.  One must not assume there is only one Content Object
   with a given exact name.  For example, due to an error or design, a
   given publisher might publish two Content Objects with the same exact
   name, or due to malice, an attacker could forge a name.  Because the
   Exclude component only applies to the next name component, when one
   performs a Get Latest Version, one needs at least two different
   Interests.  The first walks the name space /a/b/c with a range
   Exclude and the second checks for duplicate Content Objects that
   differ only in hash, for example /a/b/c/5/100.

   At this point, it is useful to walk through an example of name
   discovery.  We will use the Get Latest Version query, as that is a
   very common usage.  In this example, we use a simple approach and an
   actual implementation may use more sophisticated algorithms to
   minimize the number of Interest messages.  Let's assume we have an
   application and it knows it wants to retrieve the latest version of
   /parc.com/index.html.  It knows the full name will follow the
   structure /parc.com/index.html/version/segment/(hash_value).  The
   application emits a first Interest with the prefix /parc.com/
   index.html and (3,3) for the min/max suffix components and asks for
   right-most child.  A second system on the network responds with a
   corresponding Content Object, such as one named /parc.com/
   index.html/5/100/(hash_1).  Because this response may have come from
   cache, the consumer issues a second Interest for /parc.com/
   index.html, (3,3), right-most-child, and excludes up to and including
   5.  This may cause the Interest to travel further in the network and
   thus discover a second Content Object /parc.com/
   index.html/7/95/(hash_2).  The consumer would then issue a third
   Interest as before excluding up to and including 7.  If this Interest



Lastname                  Expires May 16, 2017                  [Page 7]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   times out (there were not negative acknowledgements), then the
   consumer assumes it discovered the most recent version available in
   the connected network (another heuristic was if the Content Object
   was very recently signed, the consumer might accept it as current).
   If the hash_2 version is acceptable (i.e. it verifies signature),
   then perhaps the consumer stops its discovery.  It may, however, want
   to check for duplicate names in which case it would issue another
   Interest for the name prefix /parc.com/index.html/7/95 and exclude
   the singleton name component hash_2.  Perhaps there is a duplicate,
   named /parc.com/index.html/7/95/(hash_3).  At this point, the
   application must determine which signature it prefers (if either) or
   apply another application-specific criteria.  Note that there could
   be more than 2 duplicate names and this process could repeat with
   another Interest that excludes both singletons hash_2 and hash_3.

3.1.2.  Other Interest fields

   The PublisherPublicKeyDigest field will limit the set of matching
   Content Objects to those that have the specified publisher public key
   digest field.  It is an exact match.  This field is usually the
   SHA-256 digest of the publisher's public key.

   The AnswerOriginKind can restrict where a Content Object comes from.
   It is a bitmask that can choose from an in-network cache (content
   store), a dynamically generated response by a publisher, or that
   allows 'stale' cache answers (see Caching below).

   The scope field is limits how far an Interest may travel.  The
   options are: local forwarder (but not other local applications),
   local applications, 1 network hop, and unlimited.

   The InterestLifetime is request by the Interest issuer for how long
   the Interest should persist in the network (and thus be able to
   elicit a response).  No intermediate system is bound to honor that
   upper limit.  In some situations, this field was used like a
   subscription to get the next piece of content once it was published.
   For example, a consumer has read the current temperature from a
   sensor, so it immediately issues a new Interest that excludes up to
   and including the current temperature version and asks to remain in
   the network for up to 10 seconds (a bit longer than the sensor
   period).  When the sensor creates the next Content Object 8 seconds
   later, there is already an Interest ready so the Content Object can
   move immediately.

   The Nonce field is used to detect Interest loops.  It is a random
   number generated for each Interest.  Every forwarder that forwards an
   Interest keeps a history of Nonce values for what it considers long
   enough to detect loops.  If it detects a duplicate Nonce, it drops



Lastname                  Expires May 16, 2017                  [Page 8]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   the Interest.  There were problems with Interest Aggregation combined
   with Nonce duplicate detection and multi-copy Interest forwarding
   that lead to undetected Interest drops (they were later worked around
   with the introduction of negative acknowledgements).

   The FaceID field is used by an application to request the Interest be
   sent to a specific peer (or group).  It only has significance on the
   origin system to bypass normal forwarding table lookup.

3.1.3.  Forwarder Behavior

   A CCNx 0.8 forwarder followed these steps to forward Interests and
   Content Objects:

   o  Interest Processing

      *  Check for duplicate Nonce and drop if found

      *  Try to aggregate the Interest in the Pending Interest
         Table (PIT)

         +  If aggregated, done

      *  Try to satisfy the Interest from the local Content Store
         (cache).

         +  If a match found, as described above, return the
            corresponding Content Object

      *  Lookup in the Forwarding Information Base (FIB)

         +  If no match, drop the Interest

         +  If forwarded, record PIT state

      *  Forward the Interest as per the FIB lookup

   o  Interest Response Timeout

      *  If this is the 1st timeout, lookup the 2nd-best FIB entry and
         if it exists, forward, otherwise done.

      *  If this is the 2nd timeout, lookup all remaining feasible FIB
         entries and send to all

      *  Beyond this time, keep the Interest until Interest Lifetime
         expires




Lastname                  Expires May 16, 2017                  [Page 9]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   o  Content Object processing

      *  Find all Interests in the PIT that the Content Object satisfies
         according to the matching rules described above.

      *  Forward the Content Object along those reverse paths, then
         remove those PIT entries.

      *  If it matched at least one PIT entry, put the Content Object in
         the Content Store

   The Interest processing path in a forwarder follows a two-best route
   then flood strategy.  Each forwarder for each name prefix in its FIB
   keeps an estimate of the round-trip time.  If an Interest goes
   unsatisfied longer than this estimate, it follows the Interest
   Response Timeout processing path.  The CCNx 0.x forwarder uses a kind
   of information foraging approach.  It will steadily decrease the RTT
   estimate used on the best path until an Interest goes unsatisfied
   then reset to the true estimate.  This means about every 8th Interest
   will trigger a send on the 2nd best path.  This infrequent use of the
   2nd best path updates that path's RTT estimate.  If neither the best
   path nor second best path yields a response, the forwarder will
   broadcast the Interest any remaining feasible FIB entries.

   The CCNx 0.x forwarder uses a set of flags on FIB entries called
   Child Inherit and Forward Capture.  Normally, the FIB is matched on a
   strict longest matching prefix.  If the Child Inherit flag is set on
   a shorter prefix, it indicates that shorter prefixes should be
   considered feasible in addition to longer prefixes.  The Forward
   Capture flag on a shorter prefix indicates that no longer prefix
   should be used (it avoids another process from "capturing" the FIB
   entry by making a longer entry).  The use of these two flags has a
   strong interaction with the two-best route then flood forwarding
   strategy as they either expand or contract the set of feasible routes
   used in Interest forwarding and Interest timeout retransmission.

3.1.4.  Content Store

   In CCNx 0.x, the Content Store is a non-persistent cache closely
   aligned with the forwarder.  A Content Object has one cache control
   directive, FreshnessSeconds.  This field, inside the signature
   envelope, is a relative time for how long a Content Object is
   considered 'fresh' in a Content Store.  If the field is not present,
   it is considered infinitely fresh.  At a forwarder, from the time a
   Content Object is most recently received and for the next
   FreshnessSeconds, the Content Object is marked as fresh.  After that
   period, it is marked as stale.  Normally, an Interest will only
   retrieve fresh Content Objects from a ContentStore, unless the



Lastname                  Expires May 16, 2017                 [Page 10]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   AnswerOriginKind bitmask is set to include stale responses.  Note
   that in CCNx 0.x, a Content Object is infinitely valid, it has no
   hard expiry time.  The only distinction is fresh or stale.

3.1.5.  Wireformat

   The CCNx 0.x network protocol used an S-expression syntax encoded in
   its own proprietary binary protocol.  A full description of this
   format, known as CCNB, is available at https://github.com/PARC/ccnx-
   protocol-rfc/blob/master/Historical/mosko-ccnb-02.txt.

3.2.  Recognized Issues with CCNx 0.8

   o  There is a strong preference for the published naming convention,
      but there is no field in an Interest that says what naming
      convention is used.  If an application uses a different naming
      convention, it may cause undesired behavior from libraries that
      expected the normal convention.

   o  The use of command markers is ambiguous because binary name
      components may look like a command marker, especially if they are
      in a name component position where one would, by the normal naming
      convention, expect a certain field.

   o  Freshness Seconds is problematic when two otherwise equivalent
      interests are forwarded by a node, where one Interest allows stale
      and one Interest wants fresh.  There is no way for the
      intermediate node to know if a response came from a stale or fresh
      cache entry or from the producer itself.

   o  The CCNB wirefomat is difficult for a newcomer to understand.  Due
      to the strong application-layer framing, an application programmer
      (especially in the C library) needed to manually construct
      network-level packets using CCNB blocks.

   o  The time for Interest forwarding, without Content Store matching,
      is approximately O(1) in the PIT and approximately O(k) in the
      FIB, where k is the number of name components in the Interest
      (some strategies could reduce this to O(log k) via a binary search
      on the FIB).  The worst-case time for forwarding a Content Object,
      however, is O(n + n * m), where n is the number of PIT entries and
      m is the average number of exclusions per PIT entry.  This arises
      because in an adversarial environment an attacker could pollute
      the PIT with many Interest that all build off a similar name
      prefix, so a forwarder would need to iterate over all of them to
      determine if a Content Object specifically satisfied any of them.





Lastname                  Expires May 16, 2017                 [Page 11]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   o  The 2-best-then-flood forwarding strategy is too chatty.
      Especially when used to request content that does not yet exist,
      the Interest will by definition timeout and cause retransmission
      over the 2nd best, then flood over the remaining FIB entries.
      This results in the Content Object, when finally produced, to
      likewise flood over all reverse paths and end up pretty much on
      every node in any of the forwarding paths.  In some early
      applications that issued such Interests for several associated
      Content Objects, it caused extreme network traffic.  Later
      implementations allowed for less chatty forwarding.

   o  The Child Inherit and Forward Capture flags combined with
      forwarding strategy (which could be one of several) combined with
      multipath and different length prefix registrations lead to a
      complex set of dependencies that is not well understood and could
      have unforeseen side effects especially when multiple applications
      are operating under the same prefix.

   o  Measuring round trip time for Interests based on FIB prefixes and
      lead to unexpected behavior.  FIB prefixes can be fairly short
      compared to application names, so it is entirely possible that a
      single FIB prefix will serve several traffic flows with different
      RTT characteristics.  For example, one flow could be static
      content that has a very short RTT and another could be dynamic
      content that has a much longer RTT.  Averaging these values will
      result in a RTT estimate in the middle that does not achieve the
      desired Interest timeout behavior for either flow.

   o  The combination of Interest Aggregation and Nonce duplicate
      detection, especially when combined with in-network Interest
      retransmission over multiple paths, can lead to a blackhole
      effect.  Imagine there are two paths from S to T.  An Interest
      from S travels along the first path, but times out as some
      intermediate node, which forwards the same Interest over the
      second path.  It is later dropped due to duplicate Nonce once the
      paths merge.  A third node, however, also sends a similar Interest
      over the second path and it gets aggregated with the
      retransmission.  That aggregated Interest will never be satisfied
      because it was dropped upstream due to duplicate None.

3.3.  Summary of NDN and CCNx 1.0 Evolution

3.3.1.  NDN Evolution








Lastname                  Expires May 16, 2017                 [Page 12]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


3.3.2.  CCNx 1.0 Evolution

   The revision of CCNx 0.8 undertaken at PARC beginning in 2013, now
   called CCNx 1.0, looked to factor the protocol behavior in to more
   independent concerns and reduce the worst-case computational costs
   especially at a forwarder.  The most far reaching change is to remove
   in-network discovery from layer 3 so a minimum viable forwarder only
   offers these services (a) - (e) above, not (f).  CCNx 1.0 operates
   via equality name match at the forwarder.  This choice lead to
   several other necessary changes because one could no longer use
   partial prefix match for exact name retrieval: the implicit hash in
   an Interest must be specified outside the name.  With these changes,
   CCNx 1.0 should operate with O(1) Content Object forwarding via the
   PIT, as opposed to the O(n + n * m) complexity.

   The changes in CCNx 1.0 have been called engineering optimizations,
   which while a desirable side benefit, ignores the inherent
   unacceptable computational cost of CCNx 0.8.  Using the "Forwarder
   Behavior" section above as an outline, let's look at the worst-case
   computational cost for each operation.

   o  Duplicate Nonce lookup: O(1) assuming a hash table.

   o  Interest aggregation: O(1) assuming an Interest selector hash
      table maintained in parallel with the PIT.  CCNx 0.8 actually used
      a hash table only on the name, then had a linked list of PIT
      entries with that prefix, so the complexity of the implementation
      was more.

   o  Satisfy Interest from the ContentStore: O(m log(m) + d log(m)),
      where d is the number of items in the Content Store and m is the
      number of exclusions in the Interest.  Let's assume the
      ContentStore is a threaded hash table.  One does an O(1) lookup on
      the Interest name prefix.  From there, one must match the next
      name components against the exclusions.  One needs to run d-1
      membership queries against the m range intervals in the exclusions
      (a singleton is just a small range).  Interval algorithms cost O(m
      log(m)) to setup build and O(log(m)) to run.  One cannot amortize
      the cost of the interval table setup because it is part of the
      Interest and could be unique with each request.

   o  Lookup an Interest in the FIB: O(log k), where k is the number of
      name components, assuming one does some sort of binary search on
      the number of name components to find the longest matching prefix.

   o  Match a received Content Object to the PIT: O(n + n * m), where n
      is the number of PIT entries and m is the average number of
      exclusions per PIT entry.  In this case, one cannot build an



Lastname                  Expires May 16, 2017                 [Page 13]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


      interval tree against the exclusions because the exclusions may be
      different for each Interest in the PIT.  In the worst case, all
      PIT entries may be a name prefix of the Content Object.  Even if
      the Content Object satisfies a PIT entry, one must continue
      iterating all other PIT entries because the ContentObject may
      satisfy them too.

   The worst-case cost may never be realized, or only realized under
   attack.  The average running time, however, could still be several
   times longer than the best case.  For example, maybe out of 1 million
   Content Store items only 10 potentially match the Interest.  That is
   still 10 times more comparisons one must do than if only one of them
   could match.  Likewise, for matching a Content Object to the PIT,
   even if only a fraction of a fraction of the millions of PIT entries
   match a Content Object, that could still be 10's or 100's to check
   against.  These smaller scale computational attacks could be much
   easier to wage against a forwarder than the worst-case conditions
   postulated above.

   In the CCNx 1.0 design, a Content Object satisfies and Interest based
   only only name (equality match), keyid restriction (equality match),
   and hash restriction (equality match).  So, there are at most only
   three checks to make.  Even if one maintains a separate index for
   each possible grouping of terms, there are only 5 tables: name, name
   + keyid, name + keyid + hash, name + hash, hash.  Therefore, the
   worst case for matching an Interest to the Content Store or matching
   a Content Object to an Interest is 5, or O(1).  Because there are no
   range exclusions, there is no need for interval data structures.

   In the new architecture, name discovery operates above layer 3.  It
   may be entirely at the edge or it may exploit smarter forwarders in-
   network that want to offer services above the minimum viable
   forwarder.  PARC has proposed several discovery protocols.  One that
   closely follows the CCNx 0.8 discovery mechanisms encodes the
   selectors in part of the Interest name, which allows minimum viable
   forwarders to move the data around and smarter forwarders as well as
   end-systems to process the queries (see https://github.com/PARC/ccnx-
   protocol-rfc/blob/master/draft-mosko-icnrg-selectors-01.txt).  At
   minimum viable forwarders, the packets are just data moved as normal.
   At smarter forwarders that implement the protocol, the packets
   represent search criteria (the Interest) and a proposed response (the
   Content Object); the smarter forwarder can verify the response
   satisfies the search criteria just as in CCNx 0.8.

   The selector-based discovery protocol just described would still have
   the worst-case runtime behavior noted above.  This computation cost,
   however, only applies to packets explicitly executing the discovery
   protocol, which in practice could be a small proportion.  A forwarder



Lastname                  Expires May 16, 2017                 [Page 14]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   may also choose to rate-limit or selectively process those via the
   protocol and other times operate as a minimum viable forwarder.

4.  Discussion of Individual Architecture & Design Commonalities and
    Differences per NDN and CCNx 1.0 Development paths

   ... below we take in succession individual topics that capture the
   points where the differences between the NDN and CCNx 1.0 approaches
   are relevant and important to discuss.  The topics listed below are
   taken from our prior discussions and are included for completeness
   only.  We can reorganize, add or delete items as we see fit.  The
   structure of each section will be the same as suggested in 4.1...

4.1.  Packet encoding

   Use of TLV encodings

4.1.1.  NDN

   .. Details and motivation...

4.1.2.  CCNx 1.0

   CCNx 1.0 uses a TLV packet format.  It allocates 2 bytes for the Type
   and 2 bytes for the Length (called the "2+2 format").  There are two
   principle reasons for using a fixed T and L length.  First, it avoids
   aliases.  For example is a 1-byte "0" the same as a 2-byte "0"?  If
   so, it means there are multiple representations of the same
   semantics, so creating packet filters becomes much harder.  If they
   are not the same, then a parser needs to differentiate them based on
   length.  The second reason is packet allocation.  Because the length
   of a L depends on how much is inside it, which might not be known at
   first, one sometimes needs to reserve space for an L field then come
   back to fill it in later.  We also believe that a fixed T and L
   length leads to a much more efficient parser because it does not need
   to branch on each T and L field.

   The 2+2 format is inefficient bit-wise because many fields are under
   255 bytes and we use maybe a dozen types, not thousands of types.  To
   address this, we have proposed two additional protocols, though these
   are not part of the standard.  The first is a compression protocol
   that is more efficient than even a protocol that can use 1 or 2 byte
   T and L fields (https://www.ietf.org/proceedings/94/slides/slides-94-
   icnrg-0.pdf).  One reason for this is that in a series of Content
   Objects, it can compress out other repeated fields, such as parts of
   the name, long cryptographic key digests, and repeated TLV blocks
   like the Validation Algorithms section.  The second is an encoding
   for 802.15.4 (or other small data environments) called the "1+0" TLV



Lastname                  Expires May 16, 2017                 [Page 15]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   format because it uses only 1 byte for both the T and the L in many
   cases (see https://www.ietf.org/mail-archive/web/icnrg/current/
   pdfs9ieLPWcJI.pdf).

   A packet contains four sections:

   o  Fixed header: A fixed length header that specifies a forwarder
      behavior (PacketType), the total packet length, the header length,
      and has a small amount of space for per-PacketType fields.

   o  Per-hop headers: A list of TLVs that are outside the signature
      envelope and are thus mutable.  These are used for network layer
      adaptation (see next item) or fields that need to change in
      flight, such as a remaining lifetime field.

   o  CCNx message: A TLV container for a Content Object or an Interest
      or an Interest Return.

   o  Validation: This is two TLV blocks, one that contains information
      about the validation, such as keyid and signing parameters like
      the crypto suite, and another that has the actual signature.  The
      signature covers the CCNx message and the first block of the
      validation section.

   CCNx 1.0 uses the same packet envelope for all CCNx messages.

4.2.  Packet structure (network adaptation, link adaptation, information
      layers)

   General: There are three layers for ICN with semantic differences -
   ICN information layer - Network adaptation layer; different network
   types may have different network adaptation layer formats - Link
   adaptation layer ("link" also includes tunnels) may be different for
   different link types

4.2.1.  NDN

   ... Details and motivation ...

4.2.2.  CCNx 1.0

   Bundled ICN information and network adaptation layer into the same
   packet header Not yet defined link adaptation layer, except
   fragmentation handling (see https://tools.ietf.org/html/draft-mosko-
   icnrg-ccnxfragmentation-01).






Lastname                  Expires May 16, 2017                 [Page 16]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


4.3.  Naming

   NDN and CCNx 1.0 has the same definitions of naming and extended it

   o  Explicitly typed components

   // definition of Data digest

   In CCNx 1.0, full name combines of "Name" and "digest" but is not
   logically tied together

4.4.  Data retrieval

4.4.1.  NDN

   Data can be retrieved by full, exact, and prefix name.  NDN includes
   an assumption that exact names are not intentionally reused by
   different data

4.4.2.  CCNx 1.0

   Data can be retrieved only using full or exact name.

4.5.  Data retrieval scoping

4.5.1.  NDN

   Name based scoping using a set of naming conventions, including
   "/localhost" and "/localhop"

4.5.2.  CCNx 1.0

   An option to scope interest forwarding using HopLimit field.  CCNx
   1.0 informally maintains the CCNx 0.x conventions of /localhost, but
   that convention is not in the standard.

   CCNx 1.0 has not adopted a /localhop convention because it can be
   achieved via the HopLimit.  We also believe that each link should be
   uniquely named to avoid confusion in the FIB and ContentStore.
   Clearly, /localhop prefixed names cannot use FIB forwarding and they
   cannot be stored in a common ContentStore.

4.6.  Opportunistic in-network caching

   Both protocols include ability to cache each forwarded data packet
   with forwarded-defined policies





Lastname                  Expires May 16, 2017                 [Page 17]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


4.6.1.  NDN

   "Fresh"/"stale" semantics for the cached data (CS can keep stale
   packet and satisfy Interests that do not request "fresh" data)

4.6.2.  CCNx 1.0

   alive/dead semantics: Requirement that CS cannot use "dead" data to
   satisfy interests (current spec only) CS alive/dead decision requires
   absolute time synchronization within required discovery resolution
   Requirement for Cache verification: if Interest specifies
   KeyRestriction, cache cannot satisfy the interest without
   verification

4.7.  In-network name discovery

4.7.1.  NDN

   Selector support

   o  As a temporary mechanism to implement in-network name discovery

   o  Open research for the adequate replacement

   "FreshnessPeriod" in Data packets as a relative time to treat Data
   "fresh" for discovery purposes

4.7.2.  CCNx 1.0

   App-defined name discovery:

   o  Manifests for static data

   o  Encoding Selectors as part of the Interest name

4.8.  Forwarding Loop Management

4.8.1.  NDN

   ...NDN assumes networks without guarantees for loopless routing
   (assumes that routing either don't exist or have high chance to
   result in looping paths)...

   PIT state to stop the interest from forwarding

   "Nonce" to detect potentially duplicated interests with ability to
   prune "duplicate" paths




Lastname                  Expires May 16, 2017                 [Page 18]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   "HopLimit" to kill interest loops in special cases

4.8.2.  CCNX 1.0

   CCNx 1.0 uses a HopLimit field in the fixed header of Interest
   packets.  This field restricts an Interest to at most 255 hops, so a
   loop will eventually terminate.  An Interest loop would likely
   terminate faster than that because once it completes its first cycle
   it would either find a Pending Interest Table entry that aggregates
   it (suppressing forwarding it) or it finds a ContentStore entry that
   satisfies it.  The vulnerability to longer loops occurs when PIT
   entries get satisfied faster than the loop period and the Content
   Object is either not cachable or a node has no cache or its cache
   entry gets evicted too fast.

   CCNx 1.0 also recommends decrementing the Interest Lifetime by an
   appropriate amount at each hop, which also serves to limit looping.

   CCNx 1.0 assumes that routing protcocols produce routes without
   permanent loops.

4.9.  Similar Interest Aggregation

4.9.1.  NDN

   Exponential-back off interval to allow interest retransmission

4.9.2.  CCNx 1.0

   CCNx 1.0 recommends this interest aggregation algorithm:

   o  Two Interests are considered 'similar' if they have the same Name,
      KeyIdRestr, and ObjHashRestr.

   o  Let the notional value InterestExpiry (a local value at the
      forwarder) be equal to the receive time plus the InterestLifetime
      (or a platform-dependent default value if not present).

   o  An Interest record (PIT entry) is considered invalid if its
      InterestExpiry time is in the past.

   o  The first reception of an Interest must be forwarded, within the
      ability of the system.

   o  A second or later reception of an Interest similar to a valid
      pending Interest from the same previous hop MUST be forwarded.  We
      consider these a retransmission requests.




Lastname                  Expires May 16, 2017                 [Page 19]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   o  A second or later reception of an Interest similar to a valid
      pending Interest from a new previous hop MAY be aggregated (not
      forwarded).

   o  Aggregating an Interest MUST extend the InterestExpiry time of the
      Interest record.  An implementation MAY keep a single
      InterestExpiry time for all previous hops or MAY keep the
      InterestExpiry time per previous hop.  In the first case, the
      forwarder might send a ContentObject down a path that is no longer
      waiting for it, in which case the previous hop (next hop of the
      Content Object) would drop it.

4.10.  Interest Payloads

4.11.  Data Security

4.11.1.  NDN

   o  Exploring signature formats: RSA, ECDSA, HMAC

   o  Command (Signed) Interests

   o  Trust schema

   o  Name based access control

4.11.2.  CCNx 1.0

   There is one packet envelope with optional Validation on both
   Interest and Content Validation can be a MIC, MAC, or Signature.  We
   allow formats like a CRC, an HMAC, Elliptical Curve, and RSA.  We
   also allow unsigned packets, which are used when trust is achieved
   via hash chains from a previously signed packet.

   Validation only covers the Message and the ValidationAlg, not the
   optional headers or fixed header.

   CCNx 1.0 allows signing Interests.  This is usually to allow a CRC on
   Interest to protect against in-network corruption.  However, the
   Interest may be signed via a stronger signature within an application
   usage.  CCNx does not recommend signing or processing signed Interest
   when the application protocol is not expecting such, as this is a
   computational denial of service vector.

   The CCNx KeyExchange (CCNxKE) protocol (see
   https://tools.ietf.org/html/draft-wood-icnrg-ccnxkeyexchange-01) is
   an on-line key exchange protocol similar to TLS 1.3 to negotiate
   encryption keys.  We believe this form of session security is



Lastname                  Expires May 16, 2017                 [Page 20]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


   intrinsically useful and should be supported within an ICN, even
   though other forms of off-line publishing encryption may be used in
   other cases.

4.12.  Fragmentation

   Both NDN and CCNx use hop-by-hop fragmentation, though the specific
   details on the fragmentation protocol differ.

4.13.  Indirect data retrieval

4.13.1.  NDN

   LINK object

4.13.2.  CCNx 1.0

   Special handling of Data packets that do not include "Name" field
   (=retrieved using data digest)

   Data is matched against "restriction" field; name is completely
   ignored

4.14.  Sync

4.14.1.  NDN

   ChronoSync, RepoSync, ChronoSync 2.0, PartialSync "refs"

4.14.2.  CCNx 1.0

   Manifest-based synchronization "refs"

5.  Security Considerations

   ...

6.  Acknowledgements

   ...

7.  IANA Considerations

   This document includes no request to IANA.







Lastname                  Expires May 16, 2017                 [Page 21]

Internet-Draft     NDN and CCNx 1.0 Design Differences     November 2016


8.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

Author's Address

   Firstname Lastname
   Affiliation
   Address
   City  ZipCode
   Country

   EMail: email
   URI:   homepage




































Lastname                  Expires May 16, 2017                 [Page 22]
