<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Design Choices and Differences for NDN and CCNx 1.0 Implementations of Information-Centric Networking</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Background"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 CCNx 0.8: Origin and Point of Commonality"/>
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Interest name matching"/>
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Other Interest fields"/>
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 Forwarder Behavior"/>
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 Content Store"/>
<link href="#rfc.section.3.1.5" rel="Chapter" title="3.1.5 Wireformat"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Recognized Issues with CCNx 0.8"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Summary of NDN and CCNx 1.0 Evolution"/>
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 NDN Evolution"/>
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 CCNx 1.0 Evolution"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Discussion of Individual Architecture &amp; Design Commonalities and Differences per NDN and CCNx 1.0 Development paths"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Packet encoding"/>
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 NDN"/>
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 CCNx 1.0"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Packet structure (network adaptation, link adaptation, information layers)"/>
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 NDN"/>
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 CCNx 1.0"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Naming"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Data retrieval"/>
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 NDN"/>
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 CCNx 1.0"/>
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Data retrieval scoping"/>
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 NDN"/>
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 CCNx 1.0"/>
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Opportunistic in-network caching"/>
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 NDN"/>
<link href="#rfc.section.4.6.2" rel="Chapter" title="4.6.2 CCNx 1.0"/>
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 In-network name discovery"/>
<link href="#rfc.section.4.7.1" rel="Chapter" title="4.7.1 NDN"/>
<link href="#rfc.section.4.7.2" rel="Chapter" title="4.7.2 CCNx 1.0"/>
<link href="#rfc.section.4.8" rel="Chapter" title="4.8 Forwarding Loop Management"/>
<link href="#rfc.section.4.8.1" rel="Chapter" title="4.8.1 NDN"/>
<link href="#rfc.section.4.8.2" rel="Chapter" title="4.8.2 CCNX 1.0"/>
<link href="#rfc.section.4.9" rel="Chapter" title="4.9 Similar Interest Aggregation"/>
<link href="#rfc.section.4.9.1" rel="Chapter" title="4.9.1 NDN"/>
<link href="#rfc.section.4.9.2" rel="Chapter" title="4.9.2 CCNx 1.0"/>
<link href="#rfc.section.4.10" rel="Chapter" title="4.10 Interest Payloads"/>
<link href="#rfc.section.4.11" rel="Chapter" title="4.11 Data Security"/>
<link href="#rfc.section.4.11.1" rel="Chapter" title="4.11.1 NDN"/>
<link href="#rfc.section.4.11.2" rel="Chapter" title="4.11.2 CCNx 1.0"/>
<link href="#rfc.section.4.12" rel="Chapter" title="4.12 Fragmentation"/>
<link href="#rfc.section.4.13" rel="Chapter" title="4.13 Indirect data retrieval"/>
<link href="#rfc.section.4.13.1" rel="Chapter" title="4.13.1 NDN"/>
<link href="#rfc.section.4.13.2" rel="Chapter" title="4.13.2 CCNx 1.0"/>
<link href="#rfc.section.4.14" rel="Chapter" title="4.14 Sync"/>
<link href="#rfc.section.4.14.1" rel="Chapter" title="4.14.1 NDN"/>
<link href="#rfc.section.4.14.2" rel="Chapter" title="4.14.2 CCNx 1.0"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Acknowledgements"/>
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="8 Normative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Lastname, F." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-icnrg-harmonization-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-11-12" />
  <meta name="dct.abstract" content="The purpose of this draft is to document the discussions of the ICN Harmonization Study Group regarding the architectural or design choices made in the NDN and CCNx 1.0 implementations and to describe the rationale (if any) underlying the choices.  " />
  <meta name="description" content="The purpose of this draft is to document the discussions of the ICN Harmonization Study Group regarding the architectural or design choices made in the NDN and CCNx 1.0 implementations and to describe the rationale (if any) underlying the choices.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Information-Centric Networking Research Group (ICNRG)</td>
  <td class="right">F. Lastname</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Affiliation</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">November 12, 2016</td>
</tr>
<tr>
  <td class="left">Expires: May 16, 2017</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Design Choices and Differences for NDN and CCNx 1.0 Implementations of Information-Centric Networking<br />
  <span class="filename">draft-icnrg-harmonization-00</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>The purpose of this draft is to document the discussions of the ICN Harmonization Study Group regarding the architectural or design choices made in the NDN and CCNx 1.0 implementations and to describe the rationale (if any) underlying the choices.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 16, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Terminology</a></li>
<li>3.   <a href="#rfc.section.3">Background</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">CCNx 0.8: Origin and Point of Commonality</a></li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Interest name matching</a></li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Other Interest fields</a></li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">Forwarder Behavior</a></li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">Content Store</a></li>
<li>3.1.5.   <a href="#rfc.section.3.1.5">Wireformat</a></li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Recognized Issues with CCNx 0.8</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Summary of NDN and CCNx 1.0 Evolution</a></li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">NDN Evolution</a></li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">CCNx 1.0 Evolution</a></li>
</ul></ul><li>4.   <a href="#rfc.section.4">Discussion of Individual Architecture &amp; Design Commonalities and Differences per NDN and CCNx 1.0 Development paths</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Packet encoding</a></li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">NDN</a></li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">CCNx 1.0</a></li>
</ul><li>4.2.   <a href="#rfc.section.4.2">Packet structure (network adaptation, link adaptation, information layers)</a></li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">NDN</a></li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">CCNx 1.0</a></li>
</ul><li>4.3.   <a href="#rfc.section.4.3">Naming</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Data retrieval</a></li>
<ul><li>4.4.1.   <a href="#rfc.section.4.4.1">NDN</a></li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">CCNx 1.0</a></li>
</ul><li>4.5.   <a href="#rfc.section.4.5">Data retrieval scoping</a></li>
<ul><li>4.5.1.   <a href="#rfc.section.4.5.1">NDN</a></li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">CCNx 1.0</a></li>
</ul><li>4.6.   <a href="#rfc.section.4.6">Opportunistic in-network caching</a></li>
<ul><li>4.6.1.   <a href="#rfc.section.4.6.1">NDN</a></li>
<li>4.6.2.   <a href="#rfc.section.4.6.2">CCNx 1.0</a></li>
</ul><li>4.7.   <a href="#rfc.section.4.7">In-network name discovery</a></li>
<ul><li>4.7.1.   <a href="#rfc.section.4.7.1">NDN</a></li>
<li>4.7.2.   <a href="#rfc.section.4.7.2">CCNx 1.0</a></li>
</ul><li>4.8.   <a href="#rfc.section.4.8">Forwarding Loop Management</a></li>
<ul><li>4.8.1.   <a href="#rfc.section.4.8.1">NDN</a></li>
<li>4.8.2.   <a href="#rfc.section.4.8.2">CCNX 1.0</a></li>
</ul><li>4.9.   <a href="#rfc.section.4.9">Similar Interest Aggregation</a></li>
<ul><li>4.9.1.   <a href="#rfc.section.4.9.1">NDN</a></li>
<li>4.9.2.   <a href="#rfc.section.4.9.2">CCNx 1.0</a></li>
</ul><li>4.10.   <a href="#rfc.section.4.10">Interest Payloads</a></li>
<li>4.11.   <a href="#rfc.section.4.11">Data Security</a></li>
<ul><li>4.11.1.   <a href="#rfc.section.4.11.1">NDN</a></li>
<li>4.11.2.   <a href="#rfc.section.4.11.2">CCNx 1.0</a></li>
</ul><li>4.12.   <a href="#rfc.section.4.12">Fragmentation</a></li>
<li>4.13.   <a href="#rfc.section.4.13">Indirect data retrieval</a></li>
<ul><li>4.13.1.   <a href="#rfc.section.4.13.1">NDN</a></li>
<li>4.13.2.   <a href="#rfc.section.4.13.2">CCNx 1.0</a></li>
</ul><li>4.14.   <a href="#rfc.section.4.14">Sync</a></li>
<ul><li>4.14.1.   <a href="#rfc.section.4.14.1">NDN</a></li>
<li>4.14.2.   <a href="#rfc.section.4.14.2">CCNx 1.0</a></li>
</ul></ul><li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">Acknowledgements</a></li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a></li>
<li>8.   <a href="#rfc.references">Normative References</a></li>
<li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">...  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.  </p>
<p id="rfc.section.2.p.2">(TBD) Reference to terminology draft </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#background" id="background">Background</a></h1>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#ccnx-0.8-origin-and-point-of-commonality" id="ccnx-0.8-origin-and-point-of-commonality">CCNx 0.8: Origin and Point of Commonality</a></h1>
<p id="rfc.section.3.1.p.1">The CCNx 0.8 research prototype produced by PARC embodied a set of network functionality and application functionality that reflects a strong application layer framing approach. At the network level, a forwarder provides several services: (a) Interest aggregation, (b) Interest forwarding, (c) Content Object forwarding along the Interest reverse path, (d) Content Object caching, (e) routing strategies, and (f) in-network discovery of content via partial Interest name matching. The application domain has all other functionality, such as reliable delivery, Interest retransmissions, signature verification, encryption, and name discovery techniques.  </p>
<p id="rfc.section.3.1.p.2">The CCNx 0.8 network protocol is built around an Interest (requst) message and a Content Object (response) message. Each Interest will bring back at most one Content Object. This is true for Interests doing in-network discovery and for Interests doing data fetches. An in-network discovery Interest expresses a name prefix and some parameters (discussed below) to limit the scope of acceptable response names. In turn, the first cache (Content Store) or producer along the Interest path that has or can generate a Content Object with satisfactory name responds with that Content Object. Thus, discovery works one request and response at a time. In part this is because a requester needs to look at the entire Content Object to determine if it truly satisfies the request based on its attributes and its provenance.  </p>
<p id="rfc.section.3.1.p.3">CCNx 0.8 matches a Content Object to an Interest (the Content Objec satisfies the Interest) based on several attributes of the Content Object and parameters in the Interest. There is not a one-to-one correspondence, so several different Content Objects could match the same Interest or the same Content Object could match several Interests; in the latter case, we call the Interests similar. Because there is not a simple rule to determine if two interests are similar, the CCNx forwarder uses a simplification: two Interests are called similar if all Content Object matching terms are equal. This was accomplished by using a hash over the wireformat of those matching terms in the Interest.  </p>
<p id="rfc.section.3.1.p.4">In CCNx 0.8, a Content Object name is a totally ordered hierarchical namespace. At the network layer, each name component is a variable length opaque byte string of 0 or more bytes. Name components use a shortlex comparison: if component A is shorter than component B, then A comes before B, otherwise if they are the same length use a byte-wise lexicographic order. Two names are sorted based on where the first difference occurs in their name components. For Names, the ordering is just based on the ordering of the first component where they differ. If one name is a proper prefix of the other, then it comes first. This ordering is called the canonical name order.  </p>
<p id="rfc.section.3.1.p.5">An Interest name comes in three types, differentiated by their intended purpose. A 'prefix' name is used in name discovery. It is not intended to match any specific Content Object, but rather to elicit a response of likely Content Objects. An 'exact' name in an Interest exactly matches a name in a Content Object. A 'full' name is not used in discovery: it should specifically identify a single Content Object because it includes the cryptographic hash of the Content Object.  </p>
<p id="rfc.section.3.1.p.6">The explicit name in a Content Object has 0 or more name components assigned by the application. Some of these may be used by routing and some may be used by application-defined protocols, such as versioning or segmentation. A Content Object name has one terminal implicit name component: the so-called implicit hash.  This is the SHA-256 hash of the Content Object itself (and thus cannot be explicit). A forwarder, when handling a Content Object, always considers the Content Object to have the implicit name component. This means that both 'prefix' and 'exact' names do in-network discovery because they are always including at least one extra name component. For example, if a Content Object has a name /foo/bar, then it's full name is /foo/bar/(hash_value). A prefix name could be /foo (matching 0 or more suffix components), the exact name is /foo/bar (matching exactly 1 suffix component) and the full name is /foo/bar/(hash_value) (matching 0 additional suffix components). The restrictions on the number of additional suffix components is critical in the type of name and the expected matching (the details in an Interest are below).  </p>
<p id="rfc.section.3.1.p.7">CCNx 0.8 used some naming conventions that extended the prior description. For example, a metadata Content Object described another Content Object. It's naming convention is /foo/bar/(version)/META/(version)/(segment)/(hash_value). The name /foo/bar/5/META/3/0/(hash_value), for example, identifies a metadata Content Object of version 3 and segment 0 that describes another Content Object names /foo/bar with version 5.  </p>
<p id="rfc.section.3.1.p.8">Because names are totally ordered, one can exploit this in a name discovery protocol. A consumer application may emit an Interest whose name is a prefix of one or more Content Objects stored at a forwarded (or peer application). The discovery protocol allows the consumer to walk the name tree rooted at the Interest prefix. The consumer can ask for left-most-child or right-most-child and it can also specify Exclusions that move a notional cursor through the sub-namespace. In addition to range exclusion, an Interest may exclude individual Content Objects. Based on the name prefix, the child direction preference, and the exclusions, a forwarder (or peer application) responds with the first Content Object in the canonical name order. One issue that was never handled well in the implementation is when there are two Content Objects that differ only in hash, but not in name. While it is possible to navigate this situation (see example below), it requires multiple Interest packets and some of the protocol libraries never satisfactorily addressed the possibility.  </p>
<p id="rfc.section.3.1.p.9">The common naming convention in CCNx 0.8 is a prefix, such as /a/b/c, followed by a version, followed by a segment number, followed by the implicit hash value: /a/b/c/version/segment/(hash_value). The version is usually a timestamp in network byte order using the minimum number of bytes for the number, but it may be any field that sorts as per canonical order. The segment is used to fragment a large piece of application data into several Content Objects. It is usually a sequential number beginning at 0. The version and segment number are indicated in the name by assuming other name components conform to UTF-8, so the version and segment number use a 'name marker' whose first byte is an invalid UTF-8 code. In CCNx 0.8, there is an ambiguity between these name markers and binary name components that are not UTF-8 and happen to begin with the same byte sequence.  </p>
<p id="rfc.section.3.1.p.10">Up to this point, we have not been including the command marker identifiers in our example names. Versions, for example, use "%FD", segments use "%00." Another special class of markers are the namespace markers. These indicate that the remaining bytes in the name component introduce a new namespace, such as for metadata (%C1.META) or repository commands (%C1.R). There is also a namespace for machine-readable name components, such as keyids (%C1.M.K%00(key id value)). In the remainder of this section, we will continue to abbreviate names and not include the command markers. A complete reference on command markers is available at https://github.com/ProjectCCNx/ccnx/blob/master/doc/technical/NameConventions.txt.  </p>
<p id="rfc.section.3.1.p.11">A CCNx 0.8 Interest is defined as Interest ::= Name, MinSuffixComponents?, MaxSuffixComponents?, PublisherPublicKeyDigest?, Exclude?, ChildSelector?, AnswerOriginKind?, Scope?, InterestLifetime?, Nonce?, FaceID?. We discuss these parameters in the following. The set of fields that determine if two interests are similar are (<em>Name</em>, <em>MinSuffixComponents</em>, <em>MaxSuffixComponents</em>, <em>PublisherPublicKeyDigest</em>, <em>Exclude</em>).  </p>
<h1 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#interest-name-matching" id="interest-name-matching">Interest name matching</a></h1>
<p id="rfc.section.3.1.1.p.1">An Interest has 'selectors' that determine how a Content Object name matches the Interest name prefix. The selectors are: (<em>MinSuffixComponents</em>, <em>MaxSuffixComponents</em>, <em>Exclude</em>, <em>ChildSelector</em>). These are all optional. If none are given in an Interest, the Interest will match any suffix of the Interest's name prefix (including 0 suffix components).  </p>
<p id="rfc.section.3.1.1.p.2">MinSuffixComponents specifies the minimum additional suffix components necessary to match and MaxSuffixComponents is similarly the maximum allowed. An exact name would specify (1,1), that is it need the implicit hash and only the implicit hash. A full name, which already has the implicit hash, would specify (0,0). A typical type of discovery is Get Latest Version, where a name is understood to be of the form /a/b/c/version/segment/(hash_value). An application emits an Interest with prefix /a/b/c with (3, 3) for the suffix components and asks for the right-most-child. This says that the application knows that /a/b/c is the specific prefix it wants, and it only needs to discover the latest (right-most) version name component.  </p>
<p id="rfc.section.3.1.1.p.3">The ChildSelector works as we have illustrated it above. An Interest name, as limited by MinSuffixComponents and MaxSuffixComponents, will induce a totally ordered subset of names rooted at the Interest name. They are totally ordered because they include the implicit hash terminal component and we will assume there are no collisions. The ChildSelector defaults to left-most-child (the first of the set). If one is only interested in the largest name, one can specify the right-most-child.  </p>
<p id="rfc.section.3.1.1.p.4">The Exclude term filters out results from the totally ordered subset of names rooted at the Interest name. It can include 0 or more range restrictions and 0 or more singleton restrictions. In typical use in discovery it is a single range restrictions to keep walking through the subset. Another common usage is to exclude specific implicit hash name components because they are not the desired result (e.g. the signature is invalid). The exclude filter only applies to the next name component after the Interest prefix. For example, if the Interest name is /a/b/c, then the Exclude will only apply to the name component after /c.  Thus, if one wants to Get Latest Version, the Interest name is /a/b/c and the Exclude range would apply to the version component of a name like /a/b/c/version/segment/(hash_value).  </p>
<p id="rfc.section.3.1.1.p.5">There are several subtleties to walking the name space via exclusions. One must not assume there is only one Content Object with a given exact name. For example, due to an error or design, a given publisher might publish two Content Objects with the same exact name, or due to malice, an attacker could forge a name. Because the Exclude component only applies to the next name component, when one performs a Get Latest Version, one needs at least two different Interests. The first walks the name space /a/b/c with a range Exclude and the second checks for duplicate Content Objects that differ only in hash, for example /a/b/c/5/100.  </p>
<p id="rfc.section.3.1.1.p.6">At this point, it is useful to walk through an example of name discovery. We will use the Get Latest Version query, as that is a very common usage. In this example, we use a simple approach and an actual implementation may use more sophisticated algorithms to minimize the number of Interest messages. Let's assume we have an application and it knows it wants to retrieve the latest version of /parc.com/index.html. It knows the full name will follow the structure /parc.com/index.html/version/segment/(hash_value). The application emits a first Interest with the prefix /parc.com/index.html and (3,3) for the min/max suffix components and asks for right-most child. A second system on the network responds with a corresponding Content Object, such as one named /parc.com/index.html/5/100/(hash_1). Because this response may have come from cache, the consumer issues a second Interest for /parc.com/index.html, (3,3), right-most-child, and excludes up to and including 5. This may cause the Interest to travel further in the network and thus discover a second Content Object /parc.com/index.html/7/95/(hash_2). The consumer would then issue a third Interest as before excluding up to and including 7. If this Interest times out (there were not negative acknowledgements), then the consumer assumes it discovered the most recent version available in the connected network (another heuristic was if the Content Object was very recently signed, the consumer might accept it as current). If the hash_2 version is acceptable (i.e. it verifies signature), then perhaps the consumer stops its discovery. It may, however, want to check for duplicate names in which case it would issue another Interest for the name prefix /parc.com/index.html/7/95 and exclude the singleton name component hash_2. Perhaps there is a duplicate, named /parc.com/index.html/7/95/(hash_3). At this point, the application must determine which signature it prefers (if either) or apply another application-specific criteria. Note that there could be more than 2 duplicate names and this process could repeat with another Interest that excludes both singletons hash_2 and hash_3.  </p>
<h1 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#other-interest-fields" id="other-interest-fields">Other Interest fields</a></h1>
<p id="rfc.section.3.1.2.p.1">The PublisherPublicKeyDigest field will limit the set of matching Content Objects to those that have the specified publisher public key digest field. It is an exact match. This field is usually the SHA-256 digest of the publisher's public key.  </p>
<p id="rfc.section.3.1.2.p.2">The AnswerOriginKind can restrict where a Content Object comes from. It is a bitmask that can choose from an in-network cache (content store), a dynamically generated response by a publisher, or that allows 'stale' cache answers (see Caching below).  </p>
<p id="rfc.section.3.1.2.p.3">The scope field is limits how far an Interest may travel. The options are: local forwarder (but not other local applications), local applications, 1 network hop, and unlimited.  </p>
<p id="rfc.section.3.1.2.p.4">The InterestLifetime is request by the Interest issuer for how long the Interest should persist in the network (and thus be able to elicit a response). No intermediate system is bound to honor that upper limit. In some situations, this field was used like a subscription to get the next piece of content once it was published. For example, a consumer has read the current temperature from a sensor, so it immediately issues a new Interest that excludes up to and including the current temperature version and asks to remain in the network for up to 10 seconds (a bit longer than the sensor period). When the sensor creates the next Content Object 8 seconds later, there is already an Interest ready so the Content Object can move immediately.  </p>
<p id="rfc.section.3.1.2.p.5">The Nonce field is used to detect Interest loops. It is a random number generated for each Interest. Every forwarder that forwards an Interest keeps a history of Nonce values for what it considers long enough to detect loops. If it detects a duplicate Nonce, it drops the Interest. There were problems with Interest Aggregation combined with Nonce duplicate detection and multi-copy Interest forwarding that lead to undetected Interest drops (they were later worked around with the introduction of negative acknowledgements).  </p>
<p id="rfc.section.3.1.2.p.6">The FaceID field is used by an application to request the Interest be sent to a specific peer (or group). It only has significance on the origin system to bypass normal forwarding table lookup.  </p>
<h1 id="rfc.section.3.1.3"><a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#forwarder-behavior" id="forwarder-behavior">Forwarder Behavior</a></h1>
<p id="rfc.section.3.1.3.p.1">A CCNx 0.8 forwarder followed these steps to forward Interests and Content Objects: </p>
<p/>

<ul>
  <li>Interest Processing <ul><li>Check for duplicate Nonce and drop if found </li><li>Try to aggregate the Interest in the Pending Interest Table (PIT) <ul><li>If aggregated, done </li></ul><p> </p></li><li>Try to satisfy the Interest from the local Content Store (cache).  <ul><li>If a match found, as described above, return the corresponding Content Object </li></ul><p> </p></li><li>Lookup in the Forwarding Information Base (FIB) <ul><li>If no match, drop the Interest </li><li>If forwarded, record PIT state </li></ul><p> </p></li><li>Forward the Interest as per the FIB lookup </li></ul><p> </p></li>
  <li>Interest Response Timeout <ul><li>If this is the 1st timeout, lookup the 2nd-best FIB entry and if it exists, forward, otherwise done.  </li><li>If this is the 2nd timeout, lookup all remaining feasible FIB entries and send to all </li><li>Beyond this time, keep the Interest until Interest Lifetime expires </li></ul><p> </p></li>
  <li>Content Object processing <ul><li>Find all Interests in the PIT that the Content Object satisfies according to the matching rules described above.  </li><li>Forward the Content Object along those reverse paths, then remove those PIT entries.  </li><li>If it matched at least one PIT entry, put the Content Object in the Content Store </li></ul><p> </p></li>
</ul>
<p id="rfc.section.3.1.3.p.3">The Interest processing path in a forwarder follows a two-best route then flood strategy. Each forwarder for each name prefix in its FIB keeps an estimate of the round-trip time. If an Interest goes unsatisfied longer than this estimate, it follows the Interest Response Timeout processing path. The CCNx 0.x forwarder uses a kind of information foraging approach. It will steadily decrease the RTT estimate used on the best path until an Interest goes unsatisfied then reset to the true estimate.  This means about every 8th Interest will trigger a send on the 2nd best path. This infrequent use of the 2nd best path updates that path's RTT estimate. If neither the best path nor second best path yields a response, the forwarder will broadcast the Interest any remaining feasible FIB entries.  </p>
<p id="rfc.section.3.1.3.p.4">The CCNx 0.x forwarder uses a set of flags on FIB entries called Child Inherit and Forward Capture. Normally, the FIB is matched on a strict longest matching prefix. If the Child Inherit flag is set on a shorter prefix, it indicates that shorter prefixes should be considered feasible in addition to longer prefixes.  The Forward Capture flag on a shorter prefix indicates that no longer prefix should be used (it avoids another process from "capturing" the FIB entry by making a longer entry).  The use of these two flags has a strong interaction with the two-best route then flood forwarding strategy as they either expand or contract the set of feasible routes used in Interest forwarding and Interest timeout retransmission.  </p>
<h1 id="rfc.section.3.1.4"><a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#content-store" id="content-store">Content Store</a></h1>
<p id="rfc.section.3.1.4.p.1">In CCNx 0.x, the Content Store is a non-persistent cache closely aligned with the forwarder. A Content Object has one cache control directive, FreshnessSeconds. This field, inside the signature envelope, is a relative time for how long a Content Object is considered 'fresh' in a Content Store. If the field is not present, it is considered infinitely fresh. At a forwarder, from the time a Content Object is most recently received and for the next FreshnessSeconds, the Content Object is marked as fresh. After that period, it is marked as stale. Normally, an Interest will only retrieve fresh Content Objects from a ContentStore, unless the AnswerOriginKind bitmask is set to include stale responses. Note that in CCNx 0.x, a Content Object is infinitely valid, it has no hard expiry time. The only distinction is fresh or stale.  </p>
<h1 id="rfc.section.3.1.5"><a href="#rfc.section.3.1.5">3.1.5.</a> <a href="#wireformat" id="wireformat">Wireformat</a></h1>
<p id="rfc.section.3.1.5.p.1">The CCNx 0.x network protocol used an S-expression syntax encoded in its own proprietary binary protocol. A full description of this format, known as CCNB, is available at https://github.com/PARC/ccnx-protocol-rfc/blob/master/Historical/mosko-ccnb-02.txt.  </p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#recognized-issues-with-ccnx-0.8" id="recognized-issues-with-ccnx-0.8">Recognized Issues with CCNx 0.8</a></h1>
<p/>

<ul>
  <li>There is a strong preference for the published naming convention, but there is no field in an Interest that says what naming convention is used. If an application uses a different naming convention, it may cause undesired behavior from libraries that expected the normal convention.  </li>
  <li>The use of command markers is ambiguous because binary name components may look like a command marker, especially if they are in a name component position where one would, by the normal naming convention, expect a certain field.  </li>
  <li>Freshness Seconds is problematic when two otherwise equivalent interests are forwarded by a node, where one Interest allows stale and one Interest wants fresh. There is no way for the intermediate node to know if a response came from a stale or fresh cache entry or from the producer itself.  </li>
  <li>The CCNB wirefomat is difficult for a newcomer to understand.  Due to the strong application-layer framing, an application programmer (especially in the C library) needed to manually construct network-level packets using CCNB blocks.  </li>
  <li>The time for Interest forwarding, without Content Store matching, is approximately O(1) in the PIT and approximately O(k) in the FIB, where k is the number of name components in the Interest (some strategies could reduce this to O(log k) via a binary search on the FIB). The worst-case time for forwarding a Content Object, however, is O(n + n * m), where n is the number of PIT entries and m is the average number of exclusions per PIT entry. This arises because in an adversarial environment an attacker could pollute the PIT with many Interest that all build off a similar name prefix, so a forwarder would need to iterate over all of them to determine if a Content Object specifically satisfied any of them.  </li>
  <li>The 2-best-then-flood forwarding strategy is too chatty.  Especially when used to request content that does not yet exist, the Interest will by definition timeout and cause retransmission over the 2nd best, then flood over the remaining FIB entries. This results in the Content Object, when finally produced, to likewise flood over all reverse paths and end up pretty much on every node in any of the forwarding paths. In some early applications that issued such Interests for several associated Content Objects, it caused extreme network traffic. Later implementations allowed for less chatty forwarding.  </li>
  <li>The Child Inherit and Forward Capture flags combined with forwarding strategy (which could be one of several) combined with multipath and different length prefix registrations lead to a complex set of dependencies that is not well understood and could have unforeseen side effects especially when multiple applications are operating under the same prefix.  </li>
  <li>Measuring round trip time for Interests based on FIB prefixes and lead to unexpected behavior. FIB prefixes can be fairly short compared to application names, so it is entirely possible that a single FIB prefix will serve several traffic flows with different RTT characteristics. For example, one flow could be static content that has a very short RTT and another could be dynamic content that has a much longer RTT.  Averaging these values will result in a RTT estimate in the middle that does not achieve the desired Interest timeout behavior for either flow.  </li>
  <li>The combination of Interest Aggregation and Nonce duplicate detection, especially when combined with in-network Interest retransmission over multiple paths, can lead to a blackhole effect. Imagine there are two paths from S to T. An Interest from S travels along the first path, but times out as some intermediate node, which forwards the same Interest over the second path. It is later dropped due to duplicate Nonce once the paths merge. A third node, however, also sends a similar Interest over the second path and it gets aggregated with the retransmission. That aggregated Interest will never be satisfied because it was dropped upstream due to duplicate None.  </li>
</ul>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#summary-of-ndn-and-ccnx-1.0-evolution" id="summary-of-ndn-and-ccnx-1.0-evolution">Summary of NDN and CCNx 1.0 Evolution</a></h1>
<h1 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#ndn-evolution" id="ndn-evolution">NDN Evolution</a></h1>
<p/>
<h1 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2.</a> <a href="#ccnx-1.0-evolution" id="ccnx-1.0-evolution">CCNx 1.0 Evolution</a></h1>
<p id="rfc.section.3.3.2.p.1">The revision of CCNx 0.8 undertaken at PARC beginning in 2013, now called CCNx 1.0, looked to factor the protocol behavior in to more independent concerns and reduce the worst-case computational costs especially at a forwarder. The most far reaching change is to remove in-network discovery from layer 3 so a minimum viable forwarder only offers these services (a) - (e) above, not (f). CCNx 1.0 operates via equality name match at the forwarder. This choice lead to several other necessary changes because one could no longer use partial prefix match for exact name retrieval: the implicit hash in an Interest must be specified outside the name. With these changes, CCNx 1.0 should operate with O(1) Content Object forwarding via the PIT, as opposed to the O(n + n * m) complexity.  </p>
<p id="rfc.section.3.3.2.p.2">The changes in CCNx 1.0 have been called engineering optimizations, which while a desirable side benefit, ignores the inherent unacceptable computational cost of CCNx 0.8. Using the "Forwarder Behavior" section above as an outline, let's look at the worst-case computational cost for each operation.  </p>
<p/>

<ul>
  <li>Duplicate Nonce lookup: O(1) assuming a hash table.  </li>
  <li>Interest aggregation: O(1) assuming an Interest selector hash table maintained in parallel with the PIT. CCNx 0.8 actually used a hash table only on the name, then had a linked list of PIT entries with that prefix, so the complexity of the implementation was more.  </li>
  <li>Satisfy Interest from the ContentStore: O(m log(m) + d log(m)), where d is the number of items in the Content Store and m is the number of exclusions in the Interest. Let's assume the ContentStore is a threaded hash table. One does an O(1) lookup on the Interest name prefix. From there, one must match the next name components against the exclusions.  One needs to run d-1 membership queries against the m range intervals in the exclusions (a singleton is just a small range). Interval algorithms cost O(m log(m)) to setup build and O(log(m)) to run. One cannot amortize the cost of the interval table setup because it is part of the Interest and could be unique with each request.  </li>
  <li>Lookup an Interest in the FIB: O(log k), where k is the number of name components, assuming one does some sort of binary search on the number of name components to find the longest matching prefix.  </li>
  <li>Match a received Content Object to the PIT: O(n + n * m), where n is the number of PIT entries and m is the average number of exclusions per PIT entry. In this case, one cannot build an interval tree against the exclusions because the exclusions may be different for each Interest in the PIT. In the worst case, all PIT entries may be a name prefix of the Content Object. Even if the Content Object satisfies a PIT entry, one must continue iterating all other PIT entries because the ContentObject may satisfy them too.  </li>
</ul>
<p id="rfc.section.3.3.2.p.4">The worst-case cost may never be realized, or only realized under attack. The average running time, however, could still be several times longer than the best case. For example, maybe out of 1 million Content Store items only 10 potentially match the Interest. That is still 10 times more comparisons one must do than if only one of them could match. Likewise, for matching a Content Object to the PIT, even if only a fraction of a fraction of the millions of PIT entries match a Content Object, that could still be 10's or 100's to check against. These smaller scale computational attacks could be much easier to wage against a forwarder than the worst-case conditions postulated above.  </p>
<p id="rfc.section.3.3.2.p.5">In the CCNx 1.0 design, a Content Object satisfies and Interest based only only name (equality match), keyid restriction (equality match), and hash restriction (equality match). So, there are at most only three checks to make. Even if one maintains a separate index for each possible grouping of terms, there are only 5 tables: name, name + keyid, name + keyid + hash, name + hash, hash. Therefore, the worst case for matching an Interest to the Content Store or matching a Content Object to an Interest is 5, or O(1). Because there are no range exclusions, there is no need for interval data structures.  </p>
<p id="rfc.section.3.3.2.p.6">In the new architecture, name discovery operates above layer 3.  It may be entirely at the edge or it may exploit smarter forwarders in-network that want to offer services above the minimum viable forwarder. PARC has proposed several discovery protocols. One that closely follows the CCNx 0.8 discovery mechanisms encodes the selectors in part of the Interest name, which allows minimum viable forwarders to move the data around and smarter forwarders as well as end-systems to process the queries (see https://github.com/PARC/ccnx-protocol-rfc/blob/master/draft-mosko-icnrg-selectors-01.txt).  At minimum viable forwarders, the packets are just data moved as normal. At smarter forwarders that implement the protocol, the packets represent search criteria (the Interest) and a proposed response (the Content Object); the smarter forwarder can verify the response satisfies the search criteria just as in CCNx 0.8.  </p>
<p id="rfc.section.3.3.2.p.7">The selector-based discovery protocol just described would still have the worst-case runtime behavior noted above. This computation cost, however, only applies to packets explicitly executing the discovery protocol, which in practice could be a small proportion. A forwarder may also choose to rate-limit or selectively process those via the protocol and other times operate as a minimum viable forwarder.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#discussion-of-individual-architecture-design-commonalities-and-differences-per-ndn-and-ccnx-1.0-development-paths" id="discussion-of-individual-architecture-design-commonalities-and-differences-per-ndn-and-ccnx-1.0-development-paths">Discussion of Individual Architecture &amp; Design Commonalities and Differences per NDN and CCNx 1.0 Development paths</a></h1>
<p id="rfc.section.4.p.1">... below we take in succession individual topics that capture the points where the differences between the NDN and CCNx 1.0 approaches are relevant and important to discuss. The topics listed below are taken from our prior discussions and are included for completeness only. We can reorganize, add or delete items as we see fit. The structure of each section will be the same as suggested in 4.1...  </p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#packet-encoding" id="packet-encoding">Packet encoding</a></h1>
<p id="rfc.section.4.1.p.1">Use of TLV encodings </p>
<h1 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#ndn" id="ndn">NDN</a></h1>
<p id="rfc.section.4.1.1.p.1">.. Details and motivation...  </p>
<h1 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#ccnx-1.0" id="ccnx-1.0">CCNx 1.0</a></h1>
<p id="rfc.section.4.1.2.p.1">CCNx 1.0 uses a TLV packet format. It allocates 2 bytes for the Type and 2 bytes for the Length (called the "2+2 format"). There are two principle reasons for using a fixed T and L length. First, it avoids aliases. For example is a 1-byte "0" the same as a 2-byte "0"? If so, it means there are multiple representations of the same semantics, so creating packet filters becomes much harder. If they are not the same, then a parser needs to differentiate them based on length. The second reason is packet allocation. Because the length of a L depends on how much is inside it, which might not be known at first, one sometimes needs to reserve space for an L field then come back to fill it in later. We also believe that a fixed T and L length leads to a much more efficient parser because it does not need to branch on each T and L field.  </p>
<p id="rfc.section.4.1.2.p.2">The 2+2 format is inefficient bit-wise because many fields are under 255 bytes and we use maybe a dozen types, not thousands of types. To address this, we have proposed two additional protocols, though these are not part of the standard. The first is a compression protocol that is more efficient than even a protocol that can use 1 or 2 byte T and L fields (https://www.ietf.org/proceedings/94/slides/slides-94-icnrg-0.pdf).  One reason for this is that in a series of Content Objects, it can compress out other repeated fields, such as parts of the name, long cryptographic key digests, and repeated TLV blocks like the Validation Algorithms section. The second is an encoding for 802.15.4 (or other small data environments) called the "1+0" TLV format because it uses only 1 byte for both the T and the L in many cases (see https://www.ietf.org/mail-archive/web/icnrg/current/pdfs9ieLPWcJI.pdf).  </p>
<p id="rfc.section.4.1.2.p.3">A packet contains four sections: </p>
<p/>

<ul>
  <li>Fixed header: A fixed length header that specifies a forwarder behavior (PacketType), the total packet length, the header length, and has a small amount of space for per-PacketType fields.  </li>
  <li>Per-hop headers: A list of TLVs that are outside the signature envelope and are thus mutable. These are used for network layer adaptation (see next item) or fields that need to change in flight, such as a remaining lifetime field.  </li>
  <li>CCNx message: A TLV container for a Content Object or an Interest or an Interest Return.  </li>
  <li>Validation: This is two TLV blocks, one that contains information about the validation, such as keyid and signing parameters like the crypto suite, and another that has the actual signature. The signature covers the CCNx message and the first block of the validation section.  </li>
</ul>
<p id="rfc.section.4.1.2.p.5">CCNx 1.0 uses the same packet envelope for all CCNx messages.  </p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#packet-structure-network-adaptation-link-adaptation-information-layers" id="packet-structure-network-adaptation-link-adaptation-information-layers">Packet structure (network adaptation, link adaptation, information layers)</a></h1>
<p id="rfc.section.4.2.p.1">General: There are three layers for ICN with semantic differences - ICN information layer - Network adaptation layer; different network types may have different network adaptation layer formats - Link adaptation layer (&#8220;link&#8221; also includes tunnels) may be different for different link types </p>
<h1 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#ndn-1" id="ndn-1">NDN</a></h1>
<p id="rfc.section.4.2.1.p.1">... Details and motivation ...  </p>
<h1 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#ccnx-1.0-1" id="ccnx-1.0-1">CCNx 1.0</a></h1>
<p id="rfc.section.4.2.2.p.1">Bundled ICN information and network adaptation layer into the same packet header Not yet defined link adaptation layer, except fragmentation handling (see https://tools.ietf.org/html/draft-mosko-icnrg-ccnxfragmentation-01).  </p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#naming" id="naming">Naming</a></h1>
<p id="rfc.section.4.3.p.1">NDN and CCNx 1.0 has the same definitions of naming and extended it </p>
<p/>

<ul>
  <li>Explicitly typed components </li>
</ul>
<p id="rfc.section.4.3.p.3">// definition of Data digest </p>
<p id="rfc.section.4.3.p.4">In CCNx 1.0, full name combines of "Name" and "digest" but is not logically tied together </p>
<h1 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#data-retrieval" id="data-retrieval">Data retrieval</a></h1>
<h1 id="rfc.section.4.4.1"><a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#ndn-2" id="ndn-2">NDN</a></h1>
<p id="rfc.section.4.4.1.p.1">Data can be retrieved by full, exact, and prefix name. NDN includes an assumption that exact names are not intentionally reused by different data </p>
<h1 id="rfc.section.4.4.2"><a href="#rfc.section.4.4.2">4.4.2.</a> <a href="#ccnx-1.0-2" id="ccnx-1.0-2">CCNx 1.0</a></h1>
<p id="rfc.section.4.4.2.p.1">Data can be retrieved only using full or exact name.  </p>
<h1 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> <a href="#data-retrieval-scoping" id="data-retrieval-scoping">Data retrieval scoping</a></h1>
<h1 id="rfc.section.4.5.1"><a href="#rfc.section.4.5.1">4.5.1.</a> <a href="#ndn-3" id="ndn-3">NDN</a></h1>
<p id="rfc.section.4.5.1.p.1">Name based scoping using a set of naming conventions, including "/localhost" and "/localhop" </p>
<h1 id="rfc.section.4.5.2"><a href="#rfc.section.4.5.2">4.5.2.</a> <a href="#ccnx-1.0-3" id="ccnx-1.0-3">CCNx 1.0</a></h1>
<p id="rfc.section.4.5.2.p.1">An option to scope interest forwarding using HopLimit field.  CCNx 1.0 informally maintains the CCNx 0.x conventions of /localhost, but that convention is not in the standard.  </p>
<p id="rfc.section.4.5.2.p.2">CCNx 1.0 has not adopted a /localhop convention because it can be achieved via the HopLimit. We also believe that each link should be uniquely named to avoid confusion in the FIB and ContentStore. Clearly, /localhop prefixed names cannot use FIB forwarding and they cannot be stored in a common ContentStore.  </p>
<h1 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6.</a> <a href="#opportunistic-in-network-caching" id="opportunistic-in-network-caching">Opportunistic in-network caching</a></h1>
<p id="rfc.section.4.6.p.1">Both protocols include ability to cache each forwarded data packet with forwarded-defined policies </p>
<h1 id="rfc.section.4.6.1"><a href="#rfc.section.4.6.1">4.6.1.</a> <a href="#ndn-4" id="ndn-4">NDN</a></h1>
<p id="rfc.section.4.6.1.p.1">"Fresh"/"stale" semantics for the cached data (CS can keep stale packet and satisfy Interests that do not request "fresh" data) </p>
<h1 id="rfc.section.4.6.2"><a href="#rfc.section.4.6.2">4.6.2.</a> <a href="#ccnx-1.0-4" id="ccnx-1.0-4">CCNx 1.0</a></h1>
<p id="rfc.section.4.6.2.p.1">alive/dead semantics: Requirement that CS cannot use "dead" data to satisfy interests (current spec only) CS alive/dead decision requires absolute time synchronization within required discovery resolution Requirement for Cache verification: if Interest specifies KeyRestriction, cache cannot satisfy the interest without verification </p>
<h1 id="rfc.section.4.7"><a href="#rfc.section.4.7">4.7.</a> <a href="#in-network-name-discovery" id="in-network-name-discovery">In-network name discovery</a></h1>
<h1 id="rfc.section.4.7.1"><a href="#rfc.section.4.7.1">4.7.1.</a> <a href="#ndn-5" id="ndn-5">NDN</a></h1>
<p id="rfc.section.4.7.1.p.1">Selector support </p>
<p/>

<ul>
  <li>As a temporary mechanism to implement in-network name discovery </li>
  <li>Open research for the adequate replacement </li>
</ul>
<p id="rfc.section.4.7.1.p.3">"FreshnessPeriod" in Data packets as a relative time to treat Data "fresh" for discovery purposes </p>
<h1 id="rfc.section.4.7.2"><a href="#rfc.section.4.7.2">4.7.2.</a> <a href="#ccnx-1.0-5" id="ccnx-1.0-5">CCNx 1.0</a></h1>
<p id="rfc.section.4.7.2.p.1">App-defined name discovery: </p>
<p/>

<ul>
  <li>Manifests for static data </li>
  <li>Encoding Selectors as part of the Interest name </li>
</ul>
<h1 id="rfc.section.4.8"><a href="#rfc.section.4.8">4.8.</a> <a href="#forwarding-loop-management" id="forwarding-loop-management">Forwarding Loop Management</a></h1>
<h1 id="rfc.section.4.8.1"><a href="#rfc.section.4.8.1">4.8.1.</a> <a href="#ndn-6" id="ndn-6">NDN</a></h1>
<p id="rfc.section.4.8.1.p.1">...NDN assumes networks without guarantees for loopless routing (assumes that routing either don&#8217;t exist or have high chance to result in looping paths)...  </p>
<p id="rfc.section.4.8.1.p.2">PIT state to stop the interest from forwarding </p>
<p id="rfc.section.4.8.1.p.3">"Nonce" to detect potentially duplicated interests with ability to prune "duplicate" paths </p>
<p id="rfc.section.4.8.1.p.4">"HopLimit" to kill interest loops in special cases </p>
<h1 id="rfc.section.4.8.2"><a href="#rfc.section.4.8.2">4.8.2.</a> <a href="#ccnx-1.0-6" id="ccnx-1.0-6">CCNX 1.0</a></h1>
<p id="rfc.section.4.8.2.p.1">CCNx 1.0 uses a HopLimit field in the fixed header of Interest packets. This field restricts an Interest to at most 255 hops, so a loop will eventually terminate. An Interest loop would likely terminate faster than that because once it completes its first cycle it would either find a Pending Interest Table entry that aggregates it (suppressing forwarding it) or it finds a ContentStore entry that satisfies it. The vulnerability to longer loops occurs when PIT entries get satisfied faster than the loop period and the Content Object is either not cachable or a node has no cache or its cache entry gets evicted too fast.  </p>
<p id="rfc.section.4.8.2.p.2">CCNx 1.0 also recommends decrementing the Interest Lifetime by an appropriate amount at each hop, which also serves to limit looping.  </p>
<p id="rfc.section.4.8.2.p.3">CCNx 1.0 assumes that routing protcocols produce routes without permanent loops.  </p>
<h1 id="rfc.section.4.9"><a href="#rfc.section.4.9">4.9.</a> <a href="#similar-interest-aggregation" id="similar-interest-aggregation">Similar Interest Aggregation</a></h1>
<h1 id="rfc.section.4.9.1"><a href="#rfc.section.4.9.1">4.9.1.</a> <a href="#ndn-7" id="ndn-7">NDN</a></h1>
<p id="rfc.section.4.9.1.p.1">Exponential-back off interval to allow interest retransmission </p>
<h1 id="rfc.section.4.9.2"><a href="#rfc.section.4.9.2">4.9.2.</a> <a href="#ccnx-1.0-7" id="ccnx-1.0-7">CCNx 1.0</a></h1>
<p id="rfc.section.4.9.2.p.1">CCNx 1.0 recommends this interest aggregation algorithm: </p>
<p/>

<ul>
  <li>Two Interests are considered 'similar' if they have the same Name, KeyIdRestr, and ObjHashRestr.  </li>
  <li>Let the notional value InterestExpiry (a local value at the forwarder) be equal to the receive time plus the InterestLifetime (or a platform-dependent default value if not present).  </li>
  <li>An Interest record (PIT entry) is considered invalid if its InterestExpiry time is in the past.  </li>
  <li>The first reception of an Interest must be forwarded, within the ability of the system.  </li>
  <li>A second or later reception of an Interest similar to a valid pending Interest from the same previous hop MUST be forwarded. We consider these a retransmission requests.  </li>
  <li>A second or later reception of an Interest similar to a valid pending Interest from a new previous hop MAY be aggregated (not forwarded).  </li>
  <li>Aggregating an Interest MUST extend the InterestExpiry time of the Interest record. An implementation MAY keep a single InterestExpiry time for all previous hops or MAY keep the InterestExpiry time per previous hop. In the first case, the forwarder might send a ContentObject down a path that is no longer waiting for it, in which case the previous hop (next hop of the Content Object) would drop it.  </li>
</ul>
<h1 id="rfc.section.4.10"><a href="#rfc.section.4.10">4.10.</a> <a href="#interest-payloads" id="interest-payloads">Interest Payloads</a></h1>
<h1 id="rfc.section.4.11"><a href="#rfc.section.4.11">4.11.</a> <a href="#data-security" id="data-security">Data Security</a></h1>
<h1 id="rfc.section.4.11.1"><a href="#rfc.section.4.11.1">4.11.1.</a> <a href="#ndn-8" id="ndn-8">NDN</a></h1>
<p/>

<ul>
  <li>Exploring signature formats: RSA, ECDSA, HMAC </li>
  <li>Command (Signed) Interests </li>
  <li>Trust schema </li>
  <li>Name based access control </li>
</ul>
<h1 id="rfc.section.4.11.2"><a href="#rfc.section.4.11.2">4.11.2.</a> <a href="#ccnx-1.0-8" id="ccnx-1.0-8">CCNx 1.0</a></h1>
<p id="rfc.section.4.11.2.p.1">There is one packet envelope with optional Validation on both Interest and Content Validation can be a MIC, MAC, or Signature.  We allow formats like a CRC, an HMAC, Elliptical Curve, and RSA.  We also allow unsigned packets, which are used when trust is achieved via hash chains from a previously signed packet.  </p>
<p id="rfc.section.4.11.2.p.2">Validation only covers the Message and the ValidationAlg, not the optional headers or fixed header.  </p>
<p id="rfc.section.4.11.2.p.3">CCNx 1.0 allows signing Interests. This is usually to allow a CRC on Interest to protect against in-network corruption.  However, the Interest may be signed via a stronger signature within an application usage. CCNx does not recommend signing or processing signed Interest when the application protocol is not expecting such, as this is a computational denial of service vector.  </p>
<p id="rfc.section.4.11.2.p.4">The CCNx KeyExchange (CCNxKE) protocol (see https://tools.ietf.org/html/draft-wood-icnrg-ccnxkeyexchange-01) is an on-line key exchange protocol similar to TLS 1.3 to negotiate encryption keys. We believe this form of session security is intrinsically useful and should be supported within an ICN, even though other forms of off-line publishing encryption may be used in other cases.  </p>
<h1 id="rfc.section.4.12"><a href="#rfc.section.4.12">4.12.</a> <a href="#fragmentation" id="fragmentation">Fragmentation</a></h1>
<p id="rfc.section.4.12.p.1">Both NDN and CCNx use hop-by-hop fragmentation, though the specific details on the fragmentation protocol differ.  </p>
<h1 id="rfc.section.4.13"><a href="#rfc.section.4.13">4.13.</a> <a href="#indirect-data-retrieval" id="indirect-data-retrieval">Indirect data retrieval</a></h1>
<h1 id="rfc.section.4.13.1"><a href="#rfc.section.4.13.1">4.13.1.</a> <a href="#ndn-9" id="ndn-9">NDN</a></h1>
<p id="rfc.section.4.13.1.p.1">LINK object </p>
<h1 id="rfc.section.4.13.2"><a href="#rfc.section.4.13.2">4.13.2.</a> <a href="#ccnx-1.0-9" id="ccnx-1.0-9">CCNx 1.0</a></h1>
<p id="rfc.section.4.13.2.p.1">Special handling of Data packets that do not include "Name" field (=retrieved using data digest) </p>
<p id="rfc.section.4.13.2.p.2">Data is matched against "restriction" field; name is completely ignored </p>
<h1 id="rfc.section.4.14"><a href="#rfc.section.4.14">4.14.</a> <a href="#sync" id="sync">Sync</a></h1>
<h1 id="rfc.section.4.14.1"><a href="#rfc.section.4.14.1">4.14.1.</a> <a href="#ndn-10" id="ndn-10">NDN</a></h1>
<p id="rfc.section.4.14.1.p.1">ChronoSync, RepoSync, ChronoSync 2.0, PartialSync "refs" </p>
<h1 id="rfc.section.4.14.2"><a href="#rfc.section.4.14.2">4.14.2.</a> <a href="#ccnx-1.0-10" id="ccnx-1.0-10">CCNx 1.0</a></h1>
<p id="rfc.section.4.14.2.p.1">Manifest-based synchronization "refs" </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">...  </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.6.p.1">...  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.7.p.1">This document includes no request to IANA.  </p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Firstname Lastname</span> 
	  <span class="n hidden">
		<span class="family-name">Lastname</span>
	  </span>
	</span>
	<span class="org vcardline">Affiliation</span>
	<span class="adr">
	  <span class="vcardline">Address</span>

	  <span class="vcardline">
		<span class="locality">City</span>,  
		<span class="region"></span>
		<span class="code">ZipCode</span>
	  </span>
	  <span class="country-name vcardline">Country</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:email">email</a></span>

<span class="vcardline">URI: <a href="homepage">homepage</a></span>

  </address>
</div>

</body>
</html>
